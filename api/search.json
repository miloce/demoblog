[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-11-04T12:28:34.106Z","categories_index":"","tags_index":"","author_index":"Miloce"},{"id":"cda5e3e392219da3a1a5b517de2ad603","title":"堵猫猫小游戏","content":"捉住小猫\n\n\n\n游戏玩法\n点击小圆点，围住小猫。\n你点击一次，小猫走一次。\n直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。\n\n源代码游戏源代码点击下载\n","slug":"堵猫猫小游戏","date":"2023-01-13T17:02:56.000Z","categories_index":"源码分享","tags_index":"堵猫猫,小游戏,源代码","author_index":"Miloce"},{"id":"5d2cae0b2edfc85d0a8cc862969d7e7f","title":"Python发送邮件","content":"Python发送邮件smtplib 是 Python 用来发送邮件的模块，email 是用来处理邮件消息\n这里，我们使用装饰器来制作发送邮件的功能\n一、 文本信息我们使用MIMEText来发送文本信息\n12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env pythonfrom smtplib import SMTPfrom email.mime.text import MIMEText  # 发送文本信息使用的库from email.header import Header  # 设置请求的头部信息from email.utils import formataddr  # 格式化from functools import wrapsreceivers = [&#x27;a.l.kun@qq.com&#x27;,]  # 接收者为可迭代对象，可以实现邮件的群发subject = &#x27;测试邮件&#x27;  # 设置邮件的标题def decorate(fun_):        username = &#x27;2855595515@qq.com&#x27;  # 发送邮件的qq号    password_pass = &#x27;meryyupicqjjciei&#x27;  # 授权密码，有的邮箱是使用登录密码    smtp = SMTP(&#x27;smtp.qq.com&#x27;)  # 创建一个SMTP服务器，这里使用qq邮箱    smtp.login(username, password_pass)  # 登录        @wraps(fun_)    def func_mail(*args, **kwargs):        fun_(smtp, username, *args, **kwargs)  # 调用发邮件的函数        smtp.quit()  # 关闭服务器        smtp.close()      return func_mail@decoratedef mail(smtp, username):    for receiver_ in receivers:        msgRoot = MIMEText(f&quot;这是一个测试邮件，不要回复哦~~~&quot;, &quot;html&quot;, &quot;utf-8&quot;)  # 如果第二个参数为plain，则是发送纯文本信息，如果邮件有中文，就要使用utf-8        msgRoot[&quot;Subject&quot;] = Header(subject, &quot;utf-8&quot;)  # 设置文本标题        msgRoot[&#x27;From&#x27;] = formataddr((&quot;A.L.Kun&quot;, username))  # 设置发件人信息        msgRoot[&#x27;To&#x27;] = formataddr((receiver_.split(&quot;@&quot;)[0], receiver_))  # 设置收件人信息        smtp.sendmail(username, receiver_, msgRoot.as_string())  # 发送邮件        # smtp.set_debuglevel(1)  # 输出调试信息        print(receiver_.split(&quot;@&quot;)[0], &#x27;:发送完成&#x27;)if __name__ == &#x27;__main__&#x27;:    mail()\n\n\n\n\n\n\n\n\n\n\n使用装饰器的好处，可以动态创建一个发送邮件的对象，同时可以不用关注邮件的配置，只要关注邮件的内容\n二、 图片信息我们可以使用MIMEImage来读取图片数据，然后进行发送\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env pythonfrom smtplib import SMTPfrom email.mime.text import MIMEText  # 发送文本信息使用的库from email.mime.multipart import MIMEMultipart  # 可以发送多种类型的邮件from email.mime.image import MIMEImage  # 读取图片信息from email.header import Header  from email.utils import formataddr  from functools import wrapsimport osreceivers = [&#x27;a.l.kun@qq.com&#x27;,]subject = &#x27;测试邮件&#x27;pic_path = &quot;./test.jpeg&quot;def decorate(fun_):    username = &#x27;2855595515@qq.com&#x27;    password_pass = &#x27;mdsrecuicqjjciei&#x27;    smtp = SMTP(&#x27;smtp.qq.com&#x27;)    smtp.login(username, password_pass)    @wraps(fun_)    def func_mail(*args, **kwargs):        fun_(smtp, username, *args, **kwargs)        smtp.quit()        smtp.close()    return func_mail@decoratedef mail(smtp, username):    for receiver_ in receivers:        msgRoot = MIMEMultipart(&quot;related&quot;)  # 创建一个容器，可以为related模式，可以往里面添加文本、图片、附件        msgRoot[&quot;Subject&quot;] = Header(subject, &quot;utf-8&quot;)        msgRoot[&#x27;From&#x27;] = formataddr((&quot;A.L.Kun&quot;, username))        msgRoot[&#x27;To&#x27;] = formataddr((receiver_.split(&quot;@&quot;)[0], receiver_))        pic_data = open(pic_path, &quot;rb&quot;).read()  # 读取图片数据        &quot;&quot;&quot;以附件的形式发送图片&quot;&quot;&quot;        send_img_f = MIMEImage(pic_data)        # 设置头部信息，第一个参数和第二个参数都表示以附件的形式发送，最后一个表示文件的文件名        # 只要设置了这个头部信息，就是为发送附件        send_img_f.add_header(&#x27;Content-Disposition&#x27;, &#x27;attachment&#x27;, filename=(&#x27;utf-8&#x27;, &#x27;&#x27;, os.path.basename(pic_path)))        msgRoot.attach(send_img_f)  # 将图片附件添加到容器中        &quot;&quot;&quot;将图片添加到正文中&quot;&quot;&quot;        send_img_c = MIMEImage(pic_data)        # 设置图片的唯一标识，即图片的id为img1，通过`cid:img1`访问        send_img_c.add_header(&quot;Content-Id&quot;, &quot;&lt;img1&gt;&quot;)        msgRoot.attach(send_img_c)  # 要先将图片数据上传到容器中        img_text = f&quot;&quot;&quot;            &lt;p&gt;这是一张图片：&lt;/p&gt;            &lt;br&gt;&lt;img src=&quot;cid:img1&quot; width=&quot;300&quot; alt=&#123;os.path.basename(pic_path)&#125;&gt;&lt;/br&gt;        &quot;&quot;&quot;  # 使用导入的图片数据        msgRoot.attach(MIMEText(img_text, &quot;html&quot;, &quot;utf-8&quot;))        smtp.sendmail(username, receiver_, msgRoot.as_string())        print(receiver_.split(&quot;@&quot;)[0], &#x27;:发送完成&#x27;)if __name__ == &#x27;__main__&#x27;:    mail()\n\n三、 附件我们使用MIMEApplication来发送附件\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env pythonfrom smtplib import SMTPfrom email.mime.multipart import MIMEMultipartfrom email.header import Headerfrom email.mime.application import MIMEApplication  # 发送二进制附件from email.utils import formataddrfrom functools import wrapsimport osreceivers = [&#x27;a.l.kun@qq.com&#x27;,]subject = &#x27;测试邮件&#x27;file_lis = [&quot;./test2.pptx&quot;, &quot;./test.jpeg&quot;]def decorate(fun_):    username = &#x27;2855595515@qq.com&#x27;    password_pass = &#x27;mwdftrtycqjjciei&#x27;    smtp = SMTP(&#x27;smtp.qq.com&#x27;)    smtp.login(username, password_pass)    @wraps(fun_)    def func_mail(*args, **kwargs):        fun_(smtp, username, *args, **kwargs)        smtp.quit()        smtp.close()    return func_mail@decoratedef mail(smtp, username):    for receiver_ in receivers:        msgRoot = MIMEMultipart(&quot;related&quot;)  # 创建一个容器，必须为related模式，可以往里面添加文本、图片、附件        msgRoot[&quot;Subject&quot;] = Header(subject, &quot;utf-8&quot;)        msgRoot[&#x27;From&#x27;] = formataddr((&quot;A.L.Kun&quot;, username))        msgRoot[&#x27;To&#x27;] = formataddr((receiver_.split(&quot;@&quot;)[0], receiver_))        for file in file_lis:            # 创建二进制文件数据            msgFile = MIMEApplication(open(file, &quot;rb&quot;).read())            # 设置标头            msgFile.add_header(&#x27;Content-Disposition&#x27;, &#x27;attachment&#x27;, filename=(&#x27;utf-8&#x27;, &#x27;&#x27;, os.path.basename(file)))            # 将数据添加到容器中            msgRoot.attach(msgFile)        smtp.sendmail(username, receiver_, msgRoot.as_string())        print(receiver_.split(&quot;@&quot;)[0], &#x27;:发送完成&#x27;)if __name__ == &#x27;__main__&#x27;:    mail()","slug":"Python发送邮件","date":"2022-05-12T09:51:00.000Z","categories_index":"技术教程","tags_index":"python,邮箱,函数,smtp","author_index":"Miloce"},{"id":"f5ef2525f20c0d8b39c411893fc255bb","title":"Linux 实用命令","content":"实用命令：1、查看端口占用情况123456789101112131415# 查看该端口是否被占用netstat -lnp|grep 5000# 查看端口是否被占用lsof -i:&#x27;5000&#x27;# 杀死端口占用进程，根据进程号杀死kill -9 28533# 再次查看，如果查看时候提示命令不存在 ：# 需要先安装一下命令yum -y install net-tools# 最常见的还有防火墙yum install firewalld\n\n2、查看空间使用清理12345# 查看空间使用情况df -h# 查看当前目录下空间使用情况du -lh --max-depth=1\n\n3、按时间批量删除文件需要根据时间删除这个目录下的文件，&#x2F;home&#x2F;lifeccp&#x2F;dicom&#x2F;studies，清理掉20天之前的无效数据。\n1find /home/lifeccp/dicom/studies -mtime +21 -name &quot;*.*&quot; -exec rm -Rf &#123;&#125; \\;\n\n\n\n\n\n\n\n\n\n\n简要解释该Shell命令\n\n&#x2F;home&#x2F;lifeccp&#x2F;dicom&#x2F;studies ：准备要进行清理的任意目录\n-mtime：标准语句写法\n＋10：查找10天前的文件，这里用数字代表天数，＋30表示查找30天前的文件\n“*.*“：希望查找的数据类型，”*.jpg”表示查找扩展名为jpg的所有文件，”*“表示查找所有文件\n-exec：固定写法\nrm -rf：强制删除文件，包括目录\n {} \\; ：固定写法，一对大括号+空格+&#x2F;+;\n\n注意：在我本人使用的时候，发现可能会存在1-2天的延后误差，比如：删除10天前的，可能删除了12天前的，大家执行完可以检查一下\n4、按时间查找文件\n\n\n\n\n\n\n\n\n根据日期查找相关文件\n12# /recordings/ 查找的目录 ，默认当前目录ls --full-time /recordings/ | sed -n &#x27;/2018-03-21/p&#x27;\n\n\n\n\n\n\n\n\n\n\n按照日期范围查找相关文件\n1234find images/ -newermt &#x27;2021-01-01&#x27; ! -newermt &#x27;2021-01-31&#x27;# 按时间范围拷贝文件到另一台服务器（内网）scp -p ssh端口（22）&#x27;文件路径&#x27; &#x27;目标主机账号&#x27;@&#x27;IP&#x27;:&#x27;存放到目标路径&#x27;\n\n\n\n\n\n\n\n\n\n\n 统计文件个数\n12# wc -l 统计文件个数ls --full-time /recordings/ | sed -n &#x27;/2018-03-21/p&#x27; | wc -l\n\n5、文件、文件夹统计5.1、个数统计1234567891011121314151617Linux 中可以通过 ls -l 或者 find -type f 来统计文件、文件夹的个数，具体操作如下。查看某文件夹下文件的个数：ls -l | grep &quot;^-&quot; | wc -l# ls -l 列出文件及文件夹# &quot;^-&quot; 以-开头的行 文件以-开头 文件夹以d开头# wc -l 统计行数或者可以：find ./ -type f | wc -l# ./ 在当前目录查找# -type f 文件类型 -name &quot;*.conf*&quot; 根据文件后缀查找# wc -l 统计行数查看某文件夹下文件的个数，包括子文件夹：ls -lR | grep &quot;^-&quot; | wc -l# -R 递归列出子目录的文件查看某文件夹下文件夹的个数，包括子文件夹：ls -lR | grep &quot;^d&quot; | wc -l# &quot;^d&quot; 以d开头的行\n\n5.2、大小统计使用 du、df、free 进行统计，详细见下\n1、du详解12345678910111213141516171819202122232.1 du 详解Linux du 命令用于显示目录或文件的大小。du 会显示指定的目录或文件所占用的磁盘空间。语法：du [-abcDhHklmsSx] [目录或文件]参数说明：-a 或 -all：显示目录中文件的大小，单位 KB-b：显示目录中文件的大小，以字节 byte 为单位-c：显示目录中文件的大小，同时显示总和，单位 KB-k：显示目录中文件的大小，单位 KB-m：显示目录中文件的大小，单位 MB-s：仅显示目录的总值，单位 KB-h：--human-readable 以K，M，G为单位，提高信息的可读性。-x：以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-H：--si 与 -h参数相同，但是 K、M、G是以1000为换算单位--max-depth = 1 ：遍历深度实例：du -h * # 显示当前目录下文件的大小du -sh # 查看当前文件夹大小du -sh * | sort -nr # 统计当前文件夹（目录）大小，并按文件大小排序 -- 加了-h之后排序有问题du -sk filename # 查看指定文件大小使用 sort 的参数 -nr 表示要以数字排序法进行反向排序，因为我们要对目录大小做排序，所以不可以使用 human-readable 的大小输出，不然目录大小中会有 K、M 等字样，会造成排序不正确。如果有一个进程在打开一个大文件的时候，这个大文件直接被 rm 或者mv 掉，则 du 会更新统计数值，df 不会更新统计数值，还是认为空间没有释放。直到这个打开大文件的进程被Kill掉。\n\n2、df详解123456789101112131415161718192021222324252627282930312.2 df 详解Linux df 命令显示磁盘分区上可以使用的磁盘空间。df 可以查看一级文件夹大小、使用比例、档案系统及其挂入点，但对文件却无能为力。du可以查看文件及文件夹的大小。两者配合使用，非常有效。比如用 df 查看哪个一级目录过大，然后用 du 查看文件夹或文件的大小，如此便可迅速确定症结。语法：df [选项] [file]参数说明：-a： --all 包含所有的具有 0 Blocks 的文件系统，单位默认 KB-h：使用 -h 选项以 KB、MB、GB 的单位来显示，可读性高~~~（最常用）-i：查看目前档案系统 inode 的使用情形有的时候虽然档案系统还有空间，但若没有足够的 inode 来存放档案的信息，一样会不能增加新的档案。所谓的 inode 是用来存放档案及目录的基本信息 (metadata)，包含时间、档名、使用者及群组等。在分割扇区时，系统会先做出一堆 inode 以供以后使用，inode 的数量关系着系统中可以建立的档案及目录总数。如果要存的档案大部分都很小，则同样大小的硬盘中会有较多的档案，也就是说需要较多的 inode 来挂档案及目录。实例：df -hFilesystem            Size  Used Avail Use% Mounted on/dev/sda1             3.9G  300M  3.4G   8% //dev/sda7             100G  188M   95G   1% /data0/dev/sdb1             133G   80G   47G  64% /data1/dev/sda6             7.8G  218M  7.2G   3% /var/dev/sda5             7.8G  166M  7.2G   3% /tmp/dev/sda3             9.7G  2.5G  6.8G  27% /usrtmpfs                 2.0G     0  2.0G   0% /dev/shmFilesystem -- 档案系统Mounted on -- 挂入点size -- 分区容量Used -- 已使用的大小Avail -- 剩下的大小Use% -- 使用的百分比FreeBSD下，当硬盘容量已满时，可能会看到已使用的百分比超过 100%，因为 FreeBSD 会留一些空间给 root，让 root 在档案系统满时，还是可以写东西到该档案系统中，以进行管理。\n\n3、free详解12345678910111213142.3 free 详解Linux free 命令可以显示 Linux 系统中空闲的、已用的物理内存及交互区内存（swap），及被内核使用的 buffer（内核缓冲区内存）。共享内存将被忽略。语法：free [参数]             total       used       free     shared    buffers     cachedMem:      32948032   32767416     180616          0     139960   29878896-/+ buffers/cache:    2748560   30199472Swap:      8193140     664956    7528184参数说明：-b：以 Byte 为单位显示内存使用情况-k：以 KB 为单位显示内存使用情况-m：以 MB 为单位显示内存使用情况-g：以 GB 为单位显示内存使用情况-t：显示内存综合列\n\n6、查看系统信息\n\n\n\n\n\n\n\n\n查看内核版本\n12# 查看内核uname -r\n\n\n\n\n\n\n\n\n\n\n查看系统信息\n1234# 查看系统信息lsb_release -a# 没有以上的命令，可使用一下命令查看 XX为发行版名称。如 centos-releaseCat /etc/xxx-release\n\n\n\n\n\n\n\n\n\n\n 查看内核和操作系统相关信息\n12345678# 查看内核uname -r# 查看操作系统相关信息uname -a# 查看宽带实时使用率nload\n\n7、开放及查看端口\n\n\n\n\n\n\n\n\n查看已开放端口\n12# 查看开放端口firewall-cmd --list-ports\n\n\n\n\n\n\n\n\n\n\n开放及关闭端口（开放后需要要重启防火墙才生效）\n12345678# 开放单个端口firewall-cmd --zone=public --add-port=8080/tcp --permanent# 开放多个端口firewall-cmd --zone=public --add-port=20000-29999/tcp --permanent# 关闭端口firewall-cmd --zone=public --remove-port=8080/tcp --permanent\n\n（–permanent  为永久生效，不加为单次有效（重启失效））\n\n\n\n\n\n\n\n\n\n 防火墙操作\n1234567891011121314151617# 查看防火墙状态systemctl status firewalld# 开启防火墙systemctl start firewalld# 关闭防火墙systemctl stop firewalld# 重启防火墙systemctl restart firewalld# 开机自启systemctl enable firewalld# 开机禁用systemctl disable firewalld\n\n8、文件夹或文件权限赋予\n\n\n\n\n\n\n\n\n给.sh文件赋予可执行权限\n1234chmod +x  文件名# 示例chmod +x test.sh\n\n8.1、符号类型修改法我们把九个权限分别是 user，group，others三种身份，借由u、g、o来代表，采用a表示所有权限，其余的r、w、x分别代表读、写、执行权限。使用如下表的方法\n\n比如我们要对一个文件权限为“-rwxr-xr–”修改为“-rwxrwxr-x”,则需要对用户组身份的权限追加w权限，对其他用户追加x 权限，所以这样执行：  chmod g+w, o+x filename 或者 chmod g&#x3D;rwx, o&#x3D;rx filename\n9、扩展命令9.1、命令间隔执行1234567# 单条命令间隔执行 # -d 高亮显示本次刷新和上次刷新不同的地方  如：-d &quot;data&quot;# -t 可执行复合命令 如： &quot;ps -ef | grep ps&quot;watch -l 1 &#x27;ls&#x27;# 更多帮助watch --help","slug":"Linux-实用命令","date":"2022-05-12T09:03:00.000Z","categories_index":"技术教程","tags_index":"linux,实用命令","author_index":"Miloce"},{"id":"153b55ed301a0acf9ad4435d4749d473","title":"告别无法访问的Github","content":"最近在使用github的时候又登不上去了据说是某些不可描述的有关组织机构对该网站的DNS污染或者随机丢包造成的\n什么是DNS污染呢？\n本来很多域名对应的IP地址都是由上游可信赖的服务器提供的，这样可以降低网络上的流量压力\n但是对于有些攻击来说，他就去污染可信赖服务器里数据包，这样我一请求github，都给我登上了错误的服务器或服务器的网址\n这样的DNS攻击让我打不开还算好的，一旦让我打开些不可描述的网站，那在公共场合不得社死\ngithub解决办法\n但是自己很多项目都存在github，登不上去那不得损失很大\n所以一行必须整点儿特殊手段来访问，顺便分享一下\n1.加速器网上很多解决方案都是在分享各种加速器来登陆、像下面这个Pigcha加速器可以登陆github\n但大部分都是一些软件商的软文，先体验再收费，但是对于网络登录看完下面的分享就没必要再去付费了\n2.修改本地host既然上游服务器的域名地址被修改了，那我们直接在本地hosts文件了指定好域名对应的IP地址不就好了嘛\nhosts 文件在每个系统的位置不一，详情如下：\n\nWindows 系统：C:\\Windows\\System32\\drivers\\etc\\hosts\nLinux 系统：&#x2F;etc&#x2F;hosts\nMac（苹果电脑）系统：&#x2F;etc&#x2F;hosts\nAndroid（安卓）系统：&#x2F;system&#x2F;etc&#x2F;hosts\niPhone（iOS）系统：&#x2F;etc&#x2F;hosts\n\n然后将下面这些数据拷贝到自己电脑的hosts文件，再激活生效就可以了\n12345678910111213141516171819202122232425262728293031323334140.82.114.25                 alive.github.com140.82.112.25                 live.github.com185.199.108.154               github.githubassets.com140.82.112.22                 central.github.com185.199.108.133               desktop.githubusercontent.com185.199.108.153               assets-cdn.github.com185.199.108.133               camo.githubusercontent.com185.199.108.133               github.map.fastly.net199.232.69.194                github.global.ssl.fastly.net140.82.112.4                  gist.github.com185.199.108.153               github.io140.82.114.4                  github.com192.0.66.2                    github.blog140.82.112.6                  api.github.com185.199.108.133               raw.githubusercontent.com185.199.108.133               user-images.githubusercontent.com185.199.108.133               favicons.githubusercontent.com185.199.108.133               avatars5.githubusercontent.com185.199.108.133               avatars4.githubusercontent.com185.199.108.133               avatars3.githubusercontent.com185.199.108.133               avatars2.githubusercontent.com185.199.108.133               avatars1.githubusercontent.com185.199.108.133               avatars0.githubusercontent.com185.199.108.133               avatars.githubusercontent.com140.82.112.10                 codeload.github.com52.217.223.17                 github-cloud.s3.amazonaws.com52.217.199.41                 github-com.s3.amazonaws.com52.217.93.164                 github-production-release-asset-2e65be.s3.amazonaws.com52.217.174.129                github-production-user-asset-6210df.s3.amazonaws.com52.217.129.153                github-production-repository-file-5c1aeb.s3.amazonaws.com185.199.108.153               githubstatus.com64.71.144.202                 github.community23.100.27.125                 github.dev185.199.108.133               media.githubusercontent.com\n\n大部分情况下是直接生效，如未生效可尝试下面的办法，刷新 DNS：\n\nWindows：在 CMD 窗口输入：ipconfig &#x2F;flushdns\nLinux 命令：sudo nscd restart，如报错则须安装：sudo apt install nscd 或 sudo &#x2F;etc&#x2F;init.d&#x2F;nscd restart\nMac 命令：sudo killall -HUP mDNSResponder\n\n如果还没有生效的话，可以尝试重启一下电脑，毕竟这步操作可以解决 95 % 的电脑bug\n当然还有一些自动修改hosts文件的软件，但是有一定的风险性，所以如果手动修改hosts也没用的话，建议再参考一下镜像通道\n3.镜像通道如果手动修改hosts还不行的话，可以尝试使用镜像通道\n例如原始用法是：\n1git clone https://github.com/PaddlePaddle/PaddleDetection\n\n那加速通道就是：\n1git clone https://hub.fastgit.org/PaddlePaddle/PaddleDetection.git\n\n也就是github clone加速的时候，前面的域名用https://hub.fastgit.org/ 来替换掉https://github.com就行啦！\n当然，对于镜像通道也可以使用fastgit的开源软件：https://github.com/xljiulang/FastGithub\n","slug":"Github无法访问解决办法","date":"2021-03-28T09:10:00.000Z","categories_index":"技术教程","tags_index":"github,dns","author_index":"Miloce"},{"id":"67dd64851b6a6e8e9a90cb0d5dfa752e","title":"CSS 实现新拟态(Neumorphism) UI 风格","content":"什么是新拟态(Neumorphism) UI 风格？网上似乎还没有一个准确统一的定义。按照我个人的通俗理解，就是将界面的一部分凸起来，另一部分凹下去，形成的一种错落有致的拟物风格。代表作是乌克兰设计师 Alexander Plyuto 在各平台发布的新作品「Skeuomorph Mobile Banking」\n新拟态 UI 风格与扁平、投影风格的对比从上面这张对比图可以看出，扁平风格就像是一张纸贴在墙面上，投影风格像是浮在半空中，而新拟态风格则像是墙面上直接凸起了一块。h\n新拟态 UI 实现的方式要实现这种风格，精髓在于一个白色的阴影+一个常规阴影。一个示例如下图所示：\n新拟态 UI 风格的前端实现线工具直接生成这种风格的 CSS 代码，很强！Neumorphism CSS 在线生成器地址：https://neumorphism.io\n1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt;body &#123;    background: #ecf0f3;&#125;div &#123;    position: relative;    float: left;    width: 200px;    height: 200px;    margin-left: 80px;    margin-top: 80px;    background: #ecf0f3;&#125;.drop-shadow &#123;    border-radius: 20px;    box-shadow: 18px 18px 30px #d1d9e6, -18px -18px 30px #fff;&#125;.inner-shadow &#123;    border-radius: 20px;    box-shadow: inset 18px 18px 30px #d1d9e6, inset -18px -18px 30px #fff;&#125;.inner-shadow-ring &#123;    border-radius: 100%;    box-shadow: inset 9px 9px 15px #d1d9e6, inset -9px -9px 15px #fff;&#125;.inner-shadow-ring:before &#123;    content: &quot;&quot;;    position: absolute;    left: 20%;    top: 20%;    width: 60%;    height: 60%;    border-radius: 100%;    background: #ecf0f3;    box-shadow: 9px 9px 15px #d1d9e6, -9px -9px 15px #fff;&#125;&lt;/style&gt; &lt;div class=&quot;drop-shadow&quot;&gt;&lt;/div&gt;&lt;div class=&quot;inner-shadow&quot;&gt;&lt;/div&gt;&lt;div class=&quot;inner-shadow-ring&quot;&gt;&lt;/div&gt;\n\n","slug":"CSS-实现新拟态(Neumorphism)-UI-风格","date":"2021-03-20T08:41:00.000Z","categories_index":"技术教程","tags_index":"css,新拟态,Neumorphism","author_index":"Miloce"}]